#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

struct city {//the city struct
    int x;
    int y;
}; typedef struct city city;

//function prototypes
void shuffle(int arr[], int length);
void score(int array[], double* fitness, city cities[], int numcities);

//functions
void shuffle(int arr[], int length) {   //does the Fisherâ€“Yates shuffle
    for (int i = length - 1; i > 0; i--) {
        int j = rand() % (i + 1);
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

void score(int array[], double* fitness, city cities[],int numcities) {

    double distance = 0;   //each individual fitness is based on the distances between two cities following the order in its own array
                            //sum of all the distances between one city and the next

    for(int i = 0; i < numcities; i++) {
        if(i == numcities - 1) {
            distance += sqrt(pow(cities[array[i]].x - cities[array[0]].x, 2) + pow(cities[array[i]].y - cities[array[0]].y, 2));
            break;
        }
        distance += sqrt(pow(cities[array[i]].x - cities[array[i+1]].x, 2) + pow(cities[array[i]].y - cities[array[i+1]].y, 2));
    }
    *fitness = distance;
}


int main(int argc, char* argv[]) {

    if(argc != 3) {
        printf("The correct use of the program is './travelling num_sizeofpopulation num_howmanygenerations'\n");
        return 1;
    }//testing if the .exe was called correctly

    int sizeofpop = atoi(argv[1]);
    int numgenerations = atoi(argv[2]);
    int mutation = 1;
    time_t t;//used to set the seed for rand()
    clock_t initialtime = clock();//gets the starting time to later get the stopping time for further comparisons with the exhauston method
    srand((unsigned) time(&t));

    FILE* file = fopen("cities.bin", "rb");
    FILE* file2 = fopen("solved.bin", "rb");
    if(file == NULL || file2 == NULL) { //checks if both files were correctly opened
        printf("Error while opening file\n");
        return 1;
    }

    int numcities;
    fread(&numcities, sizeof(int), 1, file);//gets the number of cities generated by cidades.c

    struct individual {//it's horrendous to see a struct being declared inside a function, I know. this was done to avoid unnecessary dynamic allocation as it is reading the numcities from a file
        int array[numcities];
        double fitness;
    }; typedef struct individual individual;

    individual solved;
    double bruteforcetime;
    fread(&solved, sizeof(individual), 1, file2);
    fread(&bruteforcetime, sizeof(double), 1, file2); //gets the stuff from bruteforce.c

    city cities[numcities];
    individual population[sizeofpop];

    fread(cities, sizeof(city), numcities, file);//gets the city array generated by cidades.c

    //initializing
    for(int i = 0; i < sizeofpop; i++) {
        for(int j = 0; j < numcities; j++) {
            population[i].array[j] = j; //initialize each individual with the sequence {0, 1, 2, ...}
        }
    }

    for(int i = 0; i < sizeofpop; i++) {
        shuffle(population[i].array, numcities); //part 2 of initializing is shuffling them all
    }

    score(population[0].array, &population[0].fitness, cities, numcities); //initialize the variable best
    individual best;
    best = population[0];
    int generation = 1;
    int repeatedbest = 0;//needed to keep track of reocurrence in the best one
    individual previousbest;

    while((generation <= numgenerations) && (best.fitness - solved.fitness > 0.0001)) {
        //selection and scoring
        for(int i = 0; i < sizeofpop; i++) {
            score(population[i].array, &population[i].fitness, cities, numcities);
            if(population[i].fitness < best.fitness) {
                best = population[i]; //the best is the one with the lowest distance
            }
        }
    
        //mutation
        
        if(previousbest.fitness == best.fitness) {
                repeatedbest++;
        } else {
            repeatedbest = 0;
            mutation = 1;
        }
        if(repeatedbest >= 2500) { //if the best is not changing, it means it's necessary to increase or decrease the mutation
            if(mutation < numcities)
                mutation++;
            else    
                mutation = 1; //to not let it grow unnecessary bigger and keep it in a cycle
            repeatedbest = 0;
        }
        for(int i = 0; i < sizeofpop; i++) {
            for(int j = 0; j < mutation; j++) {
                int index1 = rand() % numcities, index2 = rand() % numcities;
                int temp = population[i].array[index1];
                population[i].array[index1] = population[i].array[index2];  //simple random change between two of the cities in the array, happens as many times as the number in mutation
                population[i].array[index2] = temp;
            }
        }
        population[0] = best; //I can't lose the best
        previousbest = best; //to keep track of how many times it was the same
        printf("%d %lf\n", generation, best.fitness);
        generation++;
    }
//to compile gcc travelling.c -o travelling -lm 
    clock_t finaltime = clock();
    double evolutivetime = (double)(finaltime-initialtime)/CLOCKS_PER_SEC; //calculates how many seconds it took
    if((evolutivetime - bruteforcetime) > 0) {
        printf("The evolutive algorithm took %lf seconds more than the brute force\n", evolutivetime - bruteforcetime);
    } else {
        printf("The evolutive algorithm took %lf seconds less than the brute force one\n", bruteforcetime-evolutivetime);
    }
    fclose(file);
    fclose(file2);
    return 0;
}